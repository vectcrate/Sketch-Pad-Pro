<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport optimization for touch devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch Pad Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* --- CSS RESET & VARIABLES --- */
        :root {
            /* Light Theme (Default) */
            --app-bg: #f3f4f6;
            --canvas-paper: #ffffff;
            
            /* Guide System Variables */
            --grid-color: rgba(0, 0, 0, 0.08); /* Subtle dots */
            --grid-size: 24px;
            
            /* Glassmorphism Panels */
            --panel-bg: rgba(255, 255, 255, 0.85);
            --panel-border: rgba(255, 255, 255, 0.6);
            --panel-blur: 20px;
            
            --text-primary: #111827;
            --text-secondary: #6b7280;
            
            --accent-primary: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.3);
            
            --danger-color: #ef4444;
            --danger-bg: rgba(239, 68, 68, 0.1);
            
            --divider: rgba(0, 0, 0, 0.06);
            --hover-bg: rgba(0, 0, 0, 0.05);
            
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            --radius-lg: 24px;
            --radius-md: 12px;
            
            --font-family: 'Inter', sans-serif;
            
            /* Animation Easings */
            --ease-elastic: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dark Theme Overrides */
        [data-theme="dark"] {
            --app-bg: #0f172a;
            --canvas-paper: #1e293b; 
            
            --grid-color: rgba(255, 255, 255, 0.08); /* Light dots on dark */
            
            --panel-bg: rgba(30, 41, 59, 0.85);
            --panel-border: rgba(255, 255, 255, 0.05);
            
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            
            --accent-primary: #60a5fa;
            --accent-glow: rgba(96, 165, 250, 0.3);
            
            --danger-color: #f87171;
            --danger-bg: rgba(248, 113, 113, 0.15);
            
            --divider: rgba(255, 255, 255, 0.1);
            --hover-bg: rgba(255, 255, 255, 0.08);
            
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--app-bg);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s var(--ease-smooth), color 0.5s var(--ease-smooth);
            overscroll-behavior: none; /* Prevent Pull-to-refresh on mobile */
        }

        /* --- CANVAS LAYER & GUIDE SYSTEM --- */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
            background-color: var(--canvas-paper);
            cursor: crosshair;
            transition: opacity 0.3s ease, background-color 0.5s var(--ease-smooth);
            
            /* Guide Grid Implementation (Hidden by default via size 0 or transparent) */
            /* We toggle visibility by adding a class */
            background-image: radial-gradient(var(--grid-color) 1.5px, transparent 1.5px);
            background-size: var(--grid-size) var(--grid-size);
            background-position: 0 0;
            opacity: 1;
        }

        /* Grid Visibility Toggle */
        #canvas-container:not(.show-grid) {
            background-image: none;
        }
        
        /* Eyedropper Mode */
        #canvas-container.picking {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 4l-10 10a2 2 0 0 0 0 2.83l2.83 2.83a2 2 0 0 0 2.83 0l10-10a2 2 0 0 0 0-2.83l-2.83-2.83a2 2 0 0 0-2.83 0z"/><path d="M2 22h.01"/></svg>') 0 24, crosshair;
        }
        
        #canvas-container.fade-out {
            opacity: 0.5;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #text-helper {
            position: absolute;
            display: none;
            z-index: 20;
            background: transparent;
            border: 2px solid var(--accent-primary);
            border-radius: 4px;
            color: black;
            padding: 4px;
            outline: none;
            resize: none;
            overflow: hidden;
            font-family: sans-serif;
            line-height: 1.2;
            white-space: pre;
            min-width: 50px;
            min-height: 20px;
            box-shadow: var(--shadow-sm);
            animation: popIn 0.2s var(--ease-elastic);
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 24px;
        }

        /* --- GLASS PANEL BASE STYLE --- */
        .glass-panel {
            pointer-events: auto;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--panel-blur));
            -webkit-backdrop-filter: blur(var(--panel-blur));
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow-lg);
            transition: all 0.3s var(--ease-smooth);
        }

        /* Top Header */
        .header {
            align-self: center;
            padding: 8px 12px;
            border-radius: 100px;
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 95%;
            /* Entrance Animation */
            animation: slideDown 0.8s var(--ease-elastic) both;
            animation-delay: 0.1s;
        }

        /* Title Input */
        #doc-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            background: transparent;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 6px 12px;
            width: 160px;
            text-align: center;
            transition: all 0.2s var(--ease-smooth);
        }
        #doc-title:hover {
            background: var(--hover-bg);
        }
        #doc-title:focus {
            background: var(--hover-bg);
            border-color: var(--accent-primary);
            outline: none;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981; /* Green for saved */
            margin-left: 4px;
            transform: scale(0);
            transition: transform 0.4s var(--ease-elastic);
        }
        .status-indicator.visible { transform: scale(1); }

        /* Bottom Toolbar (Dock) */
        .toolbar {
            align-self: center;
            padding: 12px 16px;
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
            max-width: 100%;
            overflow-x: auto;
            scrollbar-width: none; 
            -ms-overflow-style: none;
            /* Entrance Animation */
            animation: slideUp 0.8s var(--ease-elastic) both;
            animation-delay: 0.2s;
        }
        .toolbar::-webkit-scrollbar { display: none; }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .divider {
            width: 1px;
            height: 32px;
            background-color: var(--divider);
            margin: 0 4px;
        }

        /* Interactive Elements */
        .btn {
            position: relative;
            background: transparent;
            border: none;
            cursor: pointer;
            width: 44px;
            height: 44px;
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            transition: all 0.2s var(--ease-smooth);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            background-color: var(--hover-bg);
            color: var(--text-primary);
            transform: translateY(-2px); /* Lift Effect */
        }

        .btn:active {
            transform: scale(0.92); /* Tactile Click */
        }

        .btn.active {
            background-color: var(--accent-glow);
            color: var(--accent-primary);
            animation: pulseSelect 0.3s ease-out;
        }
        .btn.active svg {
            stroke-width: 2.5px;
        }
        
        .btn.danger:hover {
            background-color: var(--danger-bg);
            color: var(--danger-color);
        }

        .btn svg {
            width: 22px;
            height: 22px;
            stroke-width: 2;
            transition: transform 0.3s var(--ease-elastic);
        }
        
        #action-undo:hover svg { transform: rotate(-15deg); }
        #action-redo:hover svg { transform: rotate(15deg); }
        #action-clear:hover svg { transform: rotate(90deg); }

        .btn[data-shortcut]::before {
            content: attr(data-shortcut);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: var(--text-primary);
            color: var(--app-bg);
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 6px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s var(--ease-smooth);
            white-space: nowrap;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            scale: 0.9;
        }

        .btn:hover[data-shortcut]::before {
            opacity: 1;
            transform: translateX(-50%) translateY(-12px);
            scale: 1;
            transition-delay: 0.4s;
        }

        /* --- NEW COLOR PICKER BUTTON --- */
        .color-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid var(--canvas-paper);
            box-shadow: 0 0 0 2px var(--divider);
            cursor: pointer;
            margin-right: 8px;
            transition: transform 0.2s var(--ease-elastic), box-shadow 0.2s;
            background-color: #1f2937; /* Default */
        }
        .color-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 0 3px var(--accent-primary);
        }

        /* --- CUSTOM COLOR PICKER POPOVER --- */
        .color-picker-panel {
            position: absolute;
            bottom: 100px; /* Adjusted to sit above toolbar */
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            background: var(--panel-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 16px;
            width: 260px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s var(--ease-elastic);
            transform-origin: bottom center;
        }
        .color-picker-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) scale(1);
        }

        /* Saturation Map */
        .cp-saturation {
            width: 100%;
            height: 150px;
            border-radius: 8px;
            position: relative;
            cursor: crosshair;
            background-color: #f00; /* Changed dynamically via JS */
            background-image: linear-gradient(to bottom, transparent, #000), linear-gradient(to right, #fff, transparent);
            user-select: none;
        }
        .cp-cursor {
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Hue Slider */
        .cp-hue {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
        }
        .cp-hue-cursor {
            width: 12px;
            height: 12px;
            background: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            position: absolute;
            top: 0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transform: translateX(-50%);
            pointer-events: none;
        }

        /* Inputs & Controls */
        .cp-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .cp-input {
            background: var(--hover-bg);
            border: 1px solid var(--divider);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 0.75rem;
            padding: 4px 6px;
            outline: none;
            text-align: center;
        }
        .cp-input.hex { flex: 2; }
        .cp-input.rgb { flex: 1; }
        
        .cp-preview {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid var(--divider);
            flex-shrink: 0;
        }

        .cp-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
        }
        
        .cp-btn-icon {
            background: transparent;
            border: 1px solid var(--divider);
            border-radius: 6px;
            padding: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cp-btn-icon:hover, .cp-btn-icon.active {
            background: var(--hover-bg);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        /* Swatches */
        .cp-swatches {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 160px;
        }
        .cp-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        .cp-swatch:hover { transform: scale(1.2); }


        /* Custom Range Slider (App Specific) */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            width: 80px;
            margin: 0 4px;
            transition: opacity 0.3s ease;
        }
        .slider-group.hidden { display: none; }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--divider);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--canvas-paper);
            border: 2px solid var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s var(--ease-elastic);
            margin-top: 0; 
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.4);
        }

        .size-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 600;
            margin-top: 4px;
            transition: color 0.2s;
        }
        .slider-group:hover .size-label { color: var(--text-primary); }

        /* Dropdown (Mirror Options) */
        .select-wrapper {
            width: 0; 
            overflow: hidden;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.4s var(--ease-smooth);
            position: relative;
        }
        .select-wrapper.visible { 
            width: auto;
            opacity: 1; 
            transform: translateX(0);
            margin-left: 4px;
        }
        select {
            appearance: none;
            background-color: var(--hover-bg);
            border: 1px solid var(--divider);
            border-radius: 8px;
            padding: 6px 28px 6px 12px;
            font-size: 0.8rem;
            color: var(--text-primary);
            cursor: pointer;
            outline: none;
            font-family: var(--font-family);
            font-weight: 500;
            transition: background-color 0.2s;
        }
        select:hover { background-color: rgba(0,0,0,0.08); }
        
        .select-arrow {
            position: absolute;
            right: 8px; top: 50%; transform: translateY(-50%);
            pointer-events: none; width: 14px; height: 14px;
            color: var(--text-secondary);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        
        .modal-box {
            background: var(--canvas-paper);
            width: 90%;
            max-width: 500px;
            max-height: 85vh;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(40px) scale(0.9);
            transition: all 0.5s var(--ease-elastic);
            opacity: 0;
        }
        .modal-overlay.open .modal-box { 
            transform: translateY(0) scale(1); 
            opacity: 1;
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .doc-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .doc-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-radius: 16px;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
            margin-bottom: 8px;
            border: 1px solid transparent;
        }
        .doc-item:hover {
            background: var(--hover-bg);
            transform: scale(0.98);
        }
        .doc-item.active {
            background: var(--accent-glow);
            border-color: var(--accent-primary);
            transform: scale(1);
        }
        .doc-name { font-weight: 600; color: var(--text-primary); font-size: 1rem; }
        .doc-date { font-size: 0.8rem; color: var(--text-secondary); margin-top: 2px; }

        .modal-footer {
            padding: 24px;
            background: var(--app-bg);
            border-top: 1px solid var(--divider);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn-primary, .btn-secondary {
            padding: 10px 20px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s var(--ease-smooth);
        }
        .btn-primary {
            background: var(--accent-primary);
            color: white;
            border: none;
            box-shadow: 0 4px 6px var(--accent-glow);
        }
        .btn-primary:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 16px var(--accent-glow); 
        }
        .btn-primary:active { transform: scale(0.95); }
        
        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--divider);
        }
        .btn-secondary:hover { 
            background: var(--canvas-paper); 
            color: var(--text-primary); 
            border-color: var(--text-secondary);
            transform: translateY(-2px);
        }

        /* Utilities & Keyframes */
        #action-delete { display: none; }
        #action-delete.visible { display: flex; animation: popIn 0.4s var(--ease-elastic); }
        
        @keyframes popIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes slideDown {
            from { transform: translateY(-150%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(150%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes pulseSelect {
            0% { transform: scale(1); }
            50% { transform: scale(0.85); }
            100% { transform: scale(1); }
        }

        /* Reduced Motion Preference */
        @media (prefers-reduced-motion: reduce) {
            *, ::before, ::after {
                animation-duration: 0.01s !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01s !important;
                scroll-behavior: auto !important;
            }
            .header, .toolbar { animation: none; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .ui-layer { padding: 12px; }
            .toolbar { 
                width: 100%; 
                justify-content: space-between; 
                padding: 10px; 
                gap: 8px;
            }
            .header { width: 100%; justify-content: space-between; }
            #doc-title { flex: 1; width: auto; text-align: left; }
            /* Hide tooltips on touch devices to prevent double-tap issues */
            .btn[data-shortcut]::before { display: none; } 
            .divider { margin: 0 2px; }
            
            /* Picker Adjustments */
            .color-picker-panel {
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container" class="show-grid">
        <canvas id="drawing-board"></canvas>
        <textarea id="text-helper" spellcheck="false"></textarea>
    </div>

    <input type="file" id="file-input" accept=".svg,image/svg+xml" style="display: none;">
    <input type="file" id="img-input" accept="image/*" style="display: none;">

    <div class="ui-layer">
        <!-- Top Floating Header -->
        <div class="header glass-panel">
            <button class="btn" id="btn-gallery" title="My Sketches">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>
            </button>
            <div class="divider" style="height: 20px;"></div>
            <input type="text" id="doc-title" value="Untitled Sketch" spellcheck="false">
            <div class="status-indicator" id="save-status" title="Changes Saved"></div>
            <div style="flex:1"></div>
            <button class="btn" id="btn-grid" title="Toggle Grid">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8" r="1"/><circle cx="16" cy="8" r="1"/><circle cx="8" cy="16" r="1"/><circle cx="16" cy="16" r="1"/></svg>
            </button>
            <button class="btn" id="btn-theme" title="Toggle Theme">
                <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="display:block"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" style="display:none"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </button>
        </div>

        <!-- Custom Color Picker Component -->
        <div id="cp-panel" class="color-picker-panel">
            <div class="cp-saturation" id="cp-sat">
                <div class="cp-cursor" id="cp-sat-cursor"></div>
            </div>
            <div class="cp-hue" id="cp-hue">
                <div class="cp-cursor-hue" id="cp-hue-cursor"></div>
            </div>
            
            <div class="cp-row">
                <div class="cp-preview" id="cp-preview"></div>
                <input type="text" class="cp-input hex" id="cp-hex" value="#1F2937" maxlength="7">
                <input type="number" class="cp-input rgb" id="cp-r" max="255" placeholder="R">
                <input type="number" class="cp-input rgb" id="cp-g" max="255" placeholder="G">
                <input type="number" class="cp-input rgb" id="cp-b" max="255" placeholder="B">
            </div>

            <div class="cp-actions">
                <button class="cp-btn-icon" id="cp-eyedropper" title="Pick from Canvas">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 4l-10 10a2 2 0 0 0 0 2.83l2.83 2.83a2 2 0 0 0 2.83 0l10-10a2 2 0 0 0 0-2.83l-2.83-2.83a2 2 0 0 0-2.83 0z"/><path d="M2 22h.01"/></svg>
                </button>
                <div class="cp-swatches" id="cp-swatches">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>

        <!-- Bottom Floating Toolbar -->
        <div class="toolbar glass-panel">
            <!-- Properties Group -->
            <div class="tool-group">
                <!-- Color Trigger Button -->
                <div class="color-btn" id="btn-color" title="Color Picker"></div>
                
                <div class="slider-group" title="Brush Size">
                    <input type="range" id="brush-size" min="1" max="80" value="12">
                    <span class="size-label">12px</span>
                </div>

                <div class="slider-group hidden" id="angle-control" title="Nib Angle">
                    <input type="range" id="nib-angle" min="0" max="180" value="30">
                    <span class="size-label">30Â°</span>
                </div>

                <div class="slider-group hidden" id="smoothing-control" title="Stabilizer Strength">
                    <input type="range" id="smoothing-level" min="1" max="30" value="10">
                    <span class="size-label">Med</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Drawing Tools -->
            <div class="tool-group">
                <button class="btn active" id="tool-brush" data-shortcut="B" title="Brush">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M18 12l-8 8-6-6 8-8"/><path d="M22 2l-2.5 2.5"/><path d="M14.5 6.5L18 10"/></svg>
                </button>
                <button class="btn" id="tool-calligraphy" data-shortcut="C" title="Calligraphy">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line></svg>
                </button>
                <button class="btn" id="tool-smooth" data-shortcut="S" title="Smooth Pen">
                   <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12c0-2 2-4 5-4s5 2 5 4-2 4-5 4-5-2-5-4z"></path><circle cx="8" cy="12" r="1"></circle><circle cx="18" cy="12" r="1"></circle></svg>
                </button>
                 <button class="btn" id="tool-mirror" data-shortcut="M" title="Mirror">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 18v-6"/><path d="M12 8V4"/><path d="M4.2 10l7.8-6 7.8 6a2 2 0 0 1 0 3l-7.8 6-7.8-6a2 2 0 0 1 0-3z"/></svg>
                </button>
                <div class="select-wrapper" id="mirror-options">
                    <select id="mirror-axis">
                        <option value="vertical">Vert</option>
                        <option value="horizontal">Horz</option>
                        <option value="quad">Quad</option>
                    </select>
                    <svg class="select-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Objects & Editing -->
            <div class="tool-group">
                <button class="btn" id="tool-text" data-shortcut="T" title="Text">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
                </button>
                <button class="btn" id="tool-eraser" data-shortcut="E" title="Eraser">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"/><path d="M11 11L20 20"/></svg>
                </button>
                <button class="btn" id="tool-select" data-shortcut="V" title="Select / Move">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
                </button>
            </div>

            <div class="divider"></div>

            <!-- History & Actions -->
            <div class="tool-group">
                <button class="btn" id="action-undo" data-shortcut="Ctrl+Z" title="Undo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
                </button>
                <button class="btn" id="action-redo" data-shortcut="Ctrl+Y" title="Redo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></svg>
                </button>
            </div>
            
             <div class="divider"></div>
             
             <div class="tool-group">
                <button class="btn danger" id="action-delete" data-shortcut="Del" title="Delete Selected">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                </button>
                <button class="btn danger" id="action-clear" title="Clear All">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18M6 6l12 12"/></svg>
                </button>
                <button class="btn" id="action-download" title="Download PNG">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </button>
                <button class="btn" id="action-export-svg" title="Export SVG">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>
                </button>
             </div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div id="gallery-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>My Sketches</h2>
                <button class="btn" id="gallery-close" style="border:none; background:none; cursor:pointer;">
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div class="doc-list" id="doc-list">
                <!-- Document items injected here -->
            </div>
            <div class="modal-footer">
                <div style="display:flex; gap:8px;">
                    <button class="btn-secondary" id="gallery-import">Import SVG</button>
                    <button class="btn-secondary" id="gallery-import-img">Image</button>
                </div>
                <button class="btn-primary" id="gallery-new">New Sketch</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Configuration ---
            const CONFIG = {
                maxHistory: 30,
                indexKey: 'sketch_pad_index', 
                docPrefix: 'sketch_pad_doc_',
                selectionColor: 'rgba(59, 130, 246, 0.1)',
                selectionBorder: '#3b82f6',
                handleSize: 10,
                rotateHandleOffset: 25,
                defaultSwatches: ['#1f2937', '#ffffff', '#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899']
            };

            // --- COLOR PICKER MODULE ---
            class ColorPicker {
                constructor(containerId, triggerId, onChange) {
                    this.container = document.getElementById(containerId);
                    this.trigger = document.getElementById(triggerId);
                    this.onChange = onChange;
                    
                    // Elements
                    this.satMap = document.getElementById('cp-sat');
                    this.satCursor = document.getElementById('cp-sat-cursor');
                    this.hueSlider = document.getElementById('cp-hue');
                    this.hueCursor = document.getElementById('cp-hue-cursor');
                    this.preview = document.getElementById('cp-preview');
                    this.hexInput = document.getElementById('cp-hex');
                    this.rInput = document.getElementById('cp-r');
                    this.gInput = document.getElementById('cp-g');
                    this.bInput = document.getElementById('cp-b');
                    this.eyedropperBtn = document.getElementById('cp-eyedropper');
                    this.swatchesContainer = document.getElementById('cp-swatches');
                    
                    // State
                    this.h = 0; // 0-360
                    this.s = 0; // 0-100
                    this.v = 0; // 0-100
                    this.picking = false;
                    this.swatches = JSON.parse(localStorage.getItem('sketch_pad_swatches')) || CONFIG.defaultSwatches;
                    
                    this.init();
                }

                init() {
                    this.renderSwatches();
                    
                    // Toggle visibility
                    this.trigger.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggle();
                    });
                    
                    // Close when clicking outside
                    window.addEventListener('click', (e) => {
                        if (!this.container.contains(e.target) && e.target !== this.trigger) {
                            this.container.classList.remove('visible');
                        }
                    });

                    // Draggable Areas
                    this.initDrag(this.satMap, (x, y) => {
                        this.s = x * 100;
                        this.v = 100 - (y * 100);
                        this.updateUI();
                        this.emitChange();
                    });

                    this.initDrag(this.hueSlider, (x, y) => {
                        this.h = x * 360;
                        this.updateUI();
                        this.emitChange();
                    });

                    // Inputs
                    this.hexInput.addEventListener('change', () => this.setFromHex(this.hexInput.value));
                    [this.rInput, this.gInput, this.bInput].forEach(inp => {
                        inp.addEventListener('change', () => this.setFromRGB(this.rInput.value, this.gInput.value, this.bInput.value));
                    });

                    // Eyedropper
                    this.eyedropperBtn.addEventListener('click', () => this.toggleEyedropper());
                }

                initDrag(el, callback) {
                    const onMove = (e) => {
                        const rect = el.getBoundingClientRect();
                        let x = (e.clientX - rect.left) / rect.width;
                        let y = (e.clientY - rect.top) / rect.height;
                        x = Math.max(0, Math.min(1, x));
                        y = Math.max(0, Math.min(1, y));
                        callback(x, y);
                    };
                    
                    el.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        onMove(e);
                        window.addEventListener('mousemove', onMove);
                        window.addEventListener('mouseup', () => window.removeEventListener('mousemove', onMove), { once: true });
                    });
                }

                toggle() {
                    this.container.classList.toggle('visible');
                }

                toggleEyedropper() {
                    this.picking = !this.picking;
                    document.getElementById('canvas-container').classList.toggle('picking', this.picking);
                    this.eyedropperBtn.classList.toggle('active', this.picking);
                    
                    if (this.picking) {
                        this.container.classList.remove('visible');
                    }
                }

                handleCanvasClick(ctx, x, y) {
                    if (!this.picking) return false;
                    try {
                        const pixel = ctx.getImageData(x * window.devicePixelRatio, y * window.devicePixelRatio, 1, 1).data;
                        const hex = this.rgbToHex(pixel[0], pixel[1], pixel[2]);
                        this.setColor(hex);
                        this.addToSwatches(hex);
                        this.toggleEyedropper(); // Turn off
                    } catch (e) {
                        alert('Cannot pick color: Canvas is tainted by cross-origin image.');
                        this.toggleEyedropper();
                    }
                    return true;
                }

                setColor(hex) {
                    const rgb = this.hexToRgb(hex);
                    if (!rgb) return;
                    const hsv = this.rgbToHsv(rgb.r, rgb.g, rgb.b);
                    this.h = hsv.h * 360;
                    this.s = hsv.s * 100;
                    this.v = hsv.v * 100;
                    this.updateUI();
                    this.emitChange();
                }

                setFromHex(hex) {
                    this.setColor(hex);
                }

                setFromRGB(r, g, b) {
                    const hex = this.rgbToHex(parseInt(r), parseInt(g), parseInt(b));
                    this.setColor(hex);
                }

                updateUI() {
                    const rgb = this.hsvToRgb(this.h / 360, this.s / 100, this.v / 100);
                    const hex = this.rgbToHex(rgb.r, rgb.g, rgb.b);
                    
                    // Update Backgrounds
                    this.satMap.style.backgroundColor = `hsl(${this.h}, 100%, 50%)`;
                    this.preview.style.backgroundColor = hex;
                    this.trigger.style.backgroundColor = hex;

                    // Update Cursors
                    this.satCursor.style.left = `${this.s}%`;
                    this.satCursor.style.top = `${100 - this.v}%`;
                    this.hueCursor.style.left = `${this.h / 3.6}%`; // 0-100% from 0-360

                    // Update Inputs (prevent loop if focused?)
                    if (document.activeElement !== this.hexInput) this.hexInput.value = hex;
                    if (document.activeElement !== this.rInput) this.rInput.value = rgb.r;
                    if (document.activeElement !== this.gInput) this.gInput.value = rgb.g;
                    if (document.activeElement !== this.bInput) this.bInput.value = rgb.b;
                }

                emitChange() {
                    const rgb = this.hsvToRgb(this.h / 360, this.s / 100, this.v / 100);
                    const hex = this.rgbToHex(rgb.r, rgb.g, rgb.b);
                    if (this.onChange) this.onChange(hex);
                }

                addToSwatches(hex) {
                    if (this.swatches.includes(hex)) return;
                    this.swatches.unshift(hex);
                    if (this.swatches.length > 8) this.swatches.pop();
                    localStorage.setItem('sketch_pad_swatches', JSON.stringify(this.swatches));
                    this.renderSwatches();
                }

                renderSwatches() {
                    this.swatchesContainer.innerHTML = '';
                    this.swatches.forEach(hex => {
                        const el = document.createElement('div');
                        el.className = 'cp-swatch';
                        el.style.backgroundColor = hex;
                        el.addEventListener('click', () => this.setColor(hex));
                        this.swatchesContainer.appendChild(el);
                    });
                }

                // Helpers
                hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
                }

                rgbToHex(r, g, b) {
                    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                }

                rgbToHsv(r, g, b) {
                    r /= 255, g /= 255, b /= 255;
                    let max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h, s, v = max;
                    let d = max - min;
                    s = max === 0 ? 0 : d / max;
                    if (max === min) h = 0; 
                    else {
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    return { h, s, v };
                }

                hsvToRgb(h, s, v) {
                    let r, g, b;
                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
                }
            }

            // --- Theme Manager ---
            const ThemeManager = {
                init: () => {
                    const saved = localStorage.getItem('sketch_pad_theme');
                    const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const theme = saved || (systemDark ? 'dark' : 'light');
                    ThemeManager.set(theme);
                },
                set: (theme) => {
                    document.documentElement.setAttribute('data-theme', theme);
                    localStorage.setItem('sketch_pad_theme', theme);
                    
                    const moon = document.querySelector('.icon-moon');
                    const sun = document.querySelector('.icon-sun');
                    if (theme === 'dark') {
                        moon.style.display = 'none';
                        sun.style.display = 'block';
                    } else {
                        moon.style.display = 'block';
                        sun.style.display = 'none';
                    }
                    // Re-render required to update canvas fill if clear was used
                    requestAnimationFrame(render);
                },
                toggle: () => {
                    const current = document.documentElement.getAttribute('data-theme');
                    ThemeManager.set(current === 'dark' ? 'light' : 'dark');
                }
            };

            // --- DOM Elements ---
            const canvasContainer = document.getElementById('canvas-container');
            const canvas = document.getElementById('drawing-board');
            // IMPORTANT: alpha: true allows the CSS grid to show through the canvas
            const ctx = canvas.getContext('2d', { alpha: true });
            const textHelper = document.getElementById('text-helper');
            const fileInput = document.getElementById('file-input');
            const imgInput = document.getElementById('img-input');
            
            const ui = {
                size: document.getElementById('brush-size'),
                sizeLabel: document.querySelector('#brush-size + .size-label'),
                angle: document.getElementById('nib-angle'),
                angleControl: document.getElementById('angle-control'),
                angleLabel: document.querySelector('#nib-angle + .size-label'),
                
                // Smooth Pen Controls
                smoothing: document.getElementById('smoothing-level'),
                smoothingControl: document.getElementById('smoothing-control'),
                smoothingLabel: document.querySelector('#smoothing-level + .size-label'),

                // Tools
                brush: document.getElementById('tool-brush'),
                text: document.getElementById('tool-text'), // New
                calligraphy: document.getElementById('tool-calligraphy'),
                smooth: document.getElementById('tool-smooth'),
                eraser: document.getElementById('tool-eraser'),
                select: document.getElementById('tool-select'),
                mirror: document.getElementById('tool-mirror'),
                mirrorOptions: document.getElementById('mirror-options'),
                mirrorAxis: document.getElementById('mirror-axis'),
                
                // Actions
                undo: document.getElementById('action-undo'),
                redo: document.getElementById('action-redo'),
                clear: document.getElementById('action-clear'),
                delete: document.getElementById('action-delete'),
                download: document.getElementById('action-download'),
                exportSvg: document.getElementById('action-export-svg'),
                status: document.getElementById('save-status'),
                
                // Document System
                galleryBtn: document.getElementById('btn-gallery'),
                docTitle: document.getElementById('doc-title'),
                modal: document.getElementById('gallery-modal'),
                modalClose: document.getElementById('gallery-close'),
                docList: document.getElementById('doc-list'),
                btnNew: document.getElementById('gallery-new'),
                btnImport: document.getElementById('gallery-import'),
                btnImportImg: document.getElementById('gallery-import-img'),
                
                // Theme & Grid
                btnTheme: document.getElementById('btn-theme'),
                btnGrid: document.getElementById('btn-grid')
            };

            // --- App State ---
            let state = {
                docId: null, 
                
                tool: 'brush',
                color: '#1f2937', // New color state
                strokes: [],
                activeStrokes: [],
                
                nibAngle: 30,
                smoothingFactor: 10,
                mirrorMode: 'vertical',

                // Smooth Pen State
                penPos: { x: 0, y: 0 },

                // Text State
                textEntry: {
                    active: false,
                    x: 0,
                    y: 0,
                    targetIndex: -1
                },

                selection: {
                    active: false,
                    items: [], 
                    bounds: null,
                    mode: 'none', // 'move', 'resize-nw', 'rotate', etc.
                    dragStartX: 0,
                    dragStartY: 0,
                    initialBounds: null,
                    handleHit: null
                },

                isPointerDown: false,
                pointerX: 0,
                pointerY: 0,
                
                history: [],
                historyStep: -1
            };

            // --- Init Color Picker ---
            const colorPicker = new ColorPicker('cp-panel', 'btn-color', (hex) => {
                state.color = hex;
                if(state.tool === 'select') setTool('brush');
                if(state.textEntry.active) textHelper.style.color = hex;
            });

            // --- Storage & Document Manager ---
            const Storage = {
                getIndex: () => { try { return JSON.parse(localStorage.getItem(CONFIG.indexKey)) || []; } catch { return []; } },
                setIndex: (index) => { localStorage.setItem(CONFIG.indexKey, JSON.stringify(index)); },
                loadDoc: (id) => { try { return JSON.parse(localStorage.getItem(CONFIG.docPrefix + id)); } catch { return null; } },
                saveDoc: (id, content) => { localStorage.setItem(CONFIG.docPrefix + id, JSON.stringify(content)); },
                deleteDoc: (id) => { localStorage.removeItem(CONFIG.docPrefix + id); }
            };

            const DocManager = {
                create: () => {
                    const id = Date.now().toString(36) + Math.random().toString(36).substr(2);
                    const doc = { id: id, name: 'Untitled Sketch', created: Date.now(), updated: Date.now() };
                    const index = Storage.getIndex();
                    index.unshift(doc);
                    Storage.setIndex(index);
                    Storage.saveDoc(id, []);
                    return doc;
                },
                load: (id) => {
                    const content = Storage.loadDoc(id);
                    const index = Storage.getIndex();
                    const meta = index.find(d => d.id === id);
                    if (content && meta) {
                        state.docId = id;
                        state.strokes = content;
                        state.history = [];
                        state.historyStep = -1;
                        ui.docTitle.value = meta.name;
                        DocManager.saveToHistory(true);
                        render();
                        return true;
                    }
                    return false;
                },
                saveCurrent: () => {
                    if (!state.docId) return;
                    Storage.saveDoc(state.docId, state.strokes);
                    const index = Storage.getIndex();
                    const metaIndex = index.findIndex(d => d.id === state.docId);
                    if (metaIndex !== -1) {
                        index[metaIndex].updated = Date.now();
                        index[metaIndex].name = ui.docTitle.value;
                        Storage.setIndex(index);
                    }
                    showStatus();
                },
                delete: (id) => {
                    if (confirm('Delete this sketch permanently?')) {
                        Storage.deleteDoc(id);
                        const index = Storage.getIndex().filter(d => d.id !== id);
                        Storage.setIndex(index);
                        renderDocList();
                        if (state.docId === id) {
                            const newDoc = DocManager.create();
                            DocManager.load(newDoc.id);
                        }
                    }
                },
                saveToHistory: (initial = false) => {
                    // Remove Image Elements from state before saving to history/localstorage to avoid circular deps
                    // We only save the 'src' string
                    const cleanStrokes = state.strokes.map(s => {
                        if (s.type === 'image') {
                            const { imgElem, isLoading, ...rest } = s;
                            return rest;
                        }
                        return s;
                    });
                    
                    const snapshot = JSON.stringify(cleanStrokes);
                    if (state.historyStep < state.history.length - 1) {
                        state.history = state.history.slice(0, state.historyStep + 1);
                    }
                    if (initial || state.history.length === 0 || state.history[state.history.length-1] !== snapshot) {
                        state.history.push(snapshot);
                        state.historyStep++;
                    }
                    if (state.history.length > CONFIG.maxHistory) {
                        state.history.shift();
                        state.historyStep--;
                    }
                    updateHistoryUI();
                    if (!initial) DocManager.saveCurrent();
                }
            };

            // --- SVG System ---
            const SVGExporter = {
                export: (strokes, title) => {
                    const width = canvas.width / window.devicePixelRatio;
                    const height = canvas.height / window.devicePixelRatio;
                    const style = getComputedStyle(document.documentElement);
                    const paperColor = style.getPropertyValue('--canvas-paper').trim();
                    
                    let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
                    
                    // Background
                    svgContent += `<rect width="100%" height="100%" fill="${paperColor}"/>`;

                    strokes.forEach(s => {
                        // Skip erased strokes in SVG export to keep it clean, or map them to paper color
                        const color = s.type === 'eraser' ? paperColor : s.color;
                        
                        if (s.type === 'image') {
                             // SVG Image export support
                             // Note: Rotation on SVG images needs transform
                             const cx = s.x + s.w/2;
                             const cy = s.y + s.h/2;
                             const transform = s.rotation ? `transform="rotate(${s.rotation * (180/Math.PI)}, ${cx}, ${cy})"` : '';
                             svgContent += `<image href="${s.src}" x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}" ${transform} />`;

                        } else if (s.type === 'text') {
                            const safeText = s.text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
                            let transform = '';
                            if (s.rotation) {
                                const size = s.size;
                                const lines = s.text.split('\n');
                                const dim = { w: ctx.measureText(lines[0]).width, h: lines.length * size * 1.2 }; 
                                const cx = s.x + dim.w/2; 
                                const cy = s.y + dim.h/2;
                                transform = `transform="rotate(${s.rotation * (180/Math.PI)}, ${cx}, ${cy})"`;
                            }

                            const lines = s.text.split('\n');
                            const lh = s.size * 1.2;
                            lines.forEach((line, i) => {
                                svgContent += `<text x="${s.x}" y="${s.y + (i * lh) + s.size}" fill="${color}" font-family="${s.font}" font-size="${s.size}" ${transform} style="white-space: pre;">${line}</text>`;
                            });
                        } else if (s.points && s.points.length > 0) {
                            const pointsStr = s.points.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
                            svgContent += `<polyline points="${pointsStr}" fill="none" stroke="${color}" stroke-width="${s.size}" stroke-linecap="round" stroke-linejoin="round"/>`;
                        }
                    });

                    svgContent += '</svg>';
                    return svgContent;
                },
                download: (content, filename) => {
                    const blob = new Blob([content], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename + '.svg';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };

            const SVGImporter = {
                handleFile: (file) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(e.target.result, 'image/svg+xml');
                        SVGImporter.parseSVG(doc.documentElement);
                    };
                    reader.readAsText(file);
                },
                parseSVG: (svgElement) => {
                    const newStrokes = [];
                    const traverse = (node) => {
                        if (node.nodeType !== 1) return; 
                        const tag = node.tagName.toLowerCase();
                        const style = window.getComputedStyle(node);
                        const strokeColor = node.getAttribute('stroke') || style.stroke || '#000';
                        const fillColor = node.getAttribute('fill') || style.fill || '#000';
                        const width = parseFloat(node.getAttribute('stroke-width')) || parseFloat(style.strokeWidth) || 2;

                        if (tag === 'text') {
                            const x = parseFloat(node.getAttribute('x')) || 0;
                            const y = parseFloat(node.getAttribute('y')) || 0;
                            const size = parseFloat(node.getAttribute('font-size')) || 16;
                            const text = node.textContent.trim();
                            if (text) {
                                newStrokes.push({
                                    type: 'text',
                                    x: x, y: y,
                                    text: text,
                                    size: size,
                                    color: fillColor !== 'none' ? fillColor : strokeColor,
                                    rotation: 0,
                                    font: 'sans-serif'
                                });
                            }
                        } else if (['path', 'rect', 'circle', 'line', 'polyline', 'polygon'].includes(tag)) {
                            try {
                                const length = node.getTotalLength();
                                const points = [];
                                const samplingResolution = 5; 
                                for (let i = 0; i <= length; i += samplingResolution) {
                                    const pt = node.getPointAtLength(i);
                                    points.push({x: pt.x, y: pt.y});
                                }
                                const last = node.getPointAtLength(length);
                                points.push({x: last.x, y: last.y});

                                if (points.length > 0) {
                                    newStrokes.push({
                                        type: 'brush',
                                        color: strokeColor !== 'none' ? strokeColor : fillColor,
                                        size: width,
                                        points: points,
                                        angle: 30
                                    });
                                }
                            } catch (err) { console.warn("Could not parse SVG element", tag, err); }
                        }
                        Array.from(node.children).forEach(traverse);
                    };
                    traverse(svgElement);
                    if (newStrokes.length > 0) {
                        state.strokes = state.strokes.concat(newStrokes);
                        DocManager.saveToHistory();
                        render();
                        showStatus('Imported');
                    } else { alert('No readable paths found in SVG.'); }
                }
            };

            // --- Image Importer ---
            const ImageImporter = {
                handleFile: (file) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; // Fix for tainted canvas
                        img.onload = () => {
                            // Smart scaling
                            const maxW = canvas.width / window.devicePixelRatio * 0.8;
                            const maxH = canvas.height / window.devicePixelRatio * 0.8;
                            let w = img.width;
                            let h = img.height;
                            
                            if (w > maxW) {
                                h *= maxW / w;
                                w = maxW;
                            }
                            if (h > maxH) {
                                w *= maxH / h;
                                h = maxH;
                            }
                            
                            const x = (canvas.width / window.devicePixelRatio - w) / 2;
                            const y = (canvas.height / window.devicePixelRatio - h) / 2;
                            
                            state.strokes.push({
                                type: 'image',
                                x: x,
                                y: y,
                                w: w,
                                h: h,
                                src: e.target.result,
                                rotation: 0,
                                imgElem: img
                            });
                            DocManager.saveToHistory();
                            render();
                            showStatus('Image Imported');
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };


            // --- UI Functions ---
            function openGallery() { renderDocList(); ui.modal.classList.add('open'); }
            function closeGallery() { ui.modal.classList.remove('open'); }
            function renderDocList() {
                const index = Storage.getIndex();
                ui.docList.innerHTML = '';
                if (index.length === 0) {
                    ui.docList.innerHTML = '<div style="text-align:center; color:var(--text-secondary); padding:32px;">No sketches yet.<br>Start a new masterpiece!</div>';
                    return;
                }
                index.forEach(doc => {
                    const dateStr = new Date(doc.updated).toLocaleDateString(undefined, {month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'});
                    const isActive = doc.id === state.docId ? 'active' : '';
                    const item = document.createElement('div');
                    item.className = `doc-item ${isActive}`;
                    item.innerHTML = `
                        <div class="doc-info"><div class="doc-name">${doc.name}</div><div class="doc-date">${dateStr}</div></div>
                        <div class="doc-actions"><button class="btn-small delete-btn" data-id="${doc.id}" title="Delete"><svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" fill="none"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button></div>
                    `;
                    item.addEventListener('click', (e) => { if (!e.target.closest('.delete-btn')) { DocManager.load(doc.id); closeGallery(); } });
                    item.querySelector('.delete-btn').addEventListener('click', (e) => { e.stopPropagation(); DocManager.delete(doc.id); });
                    ui.docList.appendChild(item);
                });
            }

            function init() {
                ThemeManager.init();
                resizeCanvas();
                const index = Storage.getIndex();
                if (index.length > 0) { index.sort((a,b) => b.updated - a.updated); DocManager.load(index[0].id); }
                else { const newDoc = DocManager.create(); DocManager.load(newDoc.id); }
                
                // Init color
                colorPicker.setColor(state.color);
                
                render();
                updateToolUI();
            }

            function resizeCanvas() { 
                const dpr = window.devicePixelRatio || 1;
                // Set the physical pixels
                canvas.width = window.innerWidth * dpr; 
                canvas.height = window.innerHeight * dpr;
                
                // Scale the context to match the DPI
                ctx.scale(dpr, dpr);
                
                render(); 
            }

            // --- Rendering Engine ---

            function render() {
                const style = getComputedStyle(document.documentElement);
                // paperColor is still needed for eraser logic or export logic refs, but not for filling background anymore
                const paperColor = style.getPropertyValue('--canvas-paper').trim();
                const w = canvas.width / window.devicePixelRatio;
                const h = canvas.height / window.devicePixelRatio;

                ctx.save();
                
                // Clear canvas to transparent (reveals CSS grid)
                ctx.clearRect(0, 0, w, h);
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                for (let i = 0; i < state.strokes.length; i++) {
                    const stroke = state.strokes[i];
                    
                    if (stroke.type === 'eraser') {
                        // Use destination-out to punch through the canvas layer
                        // This reveals the CSS background (grid/paper) underneath
                        ctx.globalCompositeOperation = 'destination-out';
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                    }

                    if (stroke.type === 'text') {
                        renderTextObject(stroke);
                    } else if (stroke.type === 'image') {
                        renderImageObject(stroke);
                    } else if (stroke.points && stroke.points.length > 0) {
                        ctx.fillStyle = stroke.color;
                        ctx.strokeStyle = stroke.color; 
                        if (stroke.type === 'calligraphy') renderCalligraphyStroke(stroke);
                        else renderStandardStroke(stroke);
                    }
                }
                
                // Reset composite for UI overlays
                ctx.globalCompositeOperation = 'source-over';

                if (state.tool === 'mirror') drawMirrorGuides(w, h);
                if (state.tool === 'select') renderSelectionOverlay();
                
                ctx.restore();
            }

            function renderImageObject(obj) {
                // Optimize Hydration: prevent creating new Image every frame if already loading
                if (!obj.imgElem && !obj.isLoading) {
                    obj.isLoading = true; // Flag to prevent rapid re-entry
                    obj.imgElem = new Image();
                    obj.imgElem.crossOrigin = "Anonymous";
                    obj.imgElem.onload = () => {
                        obj.isLoading = false;
                        render();
                    };
                    obj.imgElem.src = obj.src;
                }
                
                if (obj.imgElem && obj.imgElem.complete) {
                    ctx.save();
                    // Rotate around center
                    const cx = obj.x + obj.w / 2;
                    const cy = obj.y + obj.h / 2;
                    ctx.translate(cx, cy);
                    ctx.rotate(obj.rotation || 0);
                    ctx.translate(-cx, -cy);
                    
                    ctx.drawImage(obj.imgElem, obj.x, obj.y, obj.w, obj.h);
                    ctx.restore();
                }
            }

            function renderStandardStroke(stroke) {
                ctx.beginPath();
                ctx.lineWidth = stroke.size;
                const p0 = stroke.points[0];
                ctx.moveTo(p0.x, p0.y);
                for (let j = 1; j < stroke.points.length; j++) {
                    ctx.lineTo(stroke.points[j].x, stroke.points[j].y);
                }
                ctx.stroke();
            }

            function renderCalligraphyStroke(stroke) {
                const points = stroke.points;
                if (points.length < 2) return;
                const angleRad = (stroke.angle || 30) * (Math.PI / 180);
                const dx = (stroke.size / 2) * Math.cos(angleRad);
                const dy = (stroke.size / 2) * Math.sin(angleRad);
                ctx.beginPath();
                ctx.moveTo(points[0].x + dx, points[0].y + dy);
                for (let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x + dx, points[i].y + dy); }
                for (let i = points.length - 1; i >= 0; i--) { ctx.lineTo(points[i].x - dx, points[i].y - dy); }
                ctx.closePath();
                ctx.fill();
            }

            function renderTextObject(obj) {
                if (state.textEntry.active && state.textEntry.targetIndex === state.strokes.indexOf(obj)) return; // Don't render if editing

                ctx.save();
                if (obj.rotation) {
                    // Rotate around text center (approximate)
                    const dims = measureTextBoundsSimple(obj);
                    const cx = dims.x + dims.w/2;
                    const cy = dims.y + dims.h/2;
                    ctx.translate(cx, cy);
                    ctx.rotate(obj.rotation);
                    ctx.translate(-cx, -cy);
                }

                ctx.font = `${obj.weight || 'normal'} ${obj.size}px ${obj.font || 'sans-serif'}`;
                ctx.fillStyle = obj.color;
                ctx.textBaseline = 'top';
                
                // Handle multiline
                const lines = obj.text.split('\n');
                const lineHeight = obj.size * 1.2;
                lines.forEach((line, i) => {
                    ctx.fillText(line, obj.x, obj.y + (i * lineHeight));
                });
                ctx.restore();
            }

            function drawMirrorGuides(w, h) {
                const mx = w / 2; const my = h / 2;
                ctx.beginPath(); ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)'; ctx.lineWidth = 1; ctx.setLineDash([10, 10]);
                if (state.mirrorMode === 'vertical' || state.mirrorMode === 'quad') { ctx.moveTo(mx, 0); ctx.lineTo(mx, h); }
                if (state.mirrorMode === 'horizontal' || state.mirrorMode === 'quad') { ctx.moveTo(0, my); ctx.lineTo(w, my); }
                ctx.stroke(); ctx.setLineDash([]);
            }

            function renderSelectionOverlay() {
                if (state.selection.items.length === 0) {
                     // Draw selection drag box if dragging empty space
                    if (state.isPointerDown && state.tool === 'select' && state.selection.mode === 'select-box') {
                        const w = state.pointerX - state.selection.dragStartX;
                        const h = state.pointerY - state.selection.dragStartY;
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);
                        ctx.strokeRect(state.selection.dragStartX, state.selection.dragStartY, w, h);
                        ctx.setLineDash([]);
                    }
                    return;
                }

                if (!state.selection.bounds) return;

                const b = state.selection.bounds;
                
                // Draw bounding box
                ctx.save();
                ctx.strokeStyle = CONFIG.selectionBorder;
                ctx.lineWidth = 1.5;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
                
                // Draw handles
                const handles = getSelectionHandles(b);
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = CONFIG.selectionBorder;
                ctx.lineWidth = 1;

                // Square handles (Resize)
                ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'].forEach(type => {
                    const h = handles[type];
                    ctx.beginPath();
                    ctx.rect(h.x, h.y, h.w, h.h);
                    ctx.fill();
                    ctx.stroke();
                });

                // Rotation handle
                const rot = handles.rot;
                const topMid = handles.n;
                ctx.beginPath();
                ctx.moveTo(topMid.x + topMid.w/2, topMid.y);
                ctx.lineTo(rot.x + rot.w/2, rot.y + rot.h/2);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(rot.x + rot.w/2, rot.y + rot.h/2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }

            function getSelectionHandles(b) {
                const s = CONFIG.handleSize;
                const hs = s / 2;
                return {
                    nw: { x: b.x - hs, y: b.y - hs, w: s, h: s },
                    ne: { x: b.x + b.w - hs, y: b.y - hs, w: s, h: s },
                    sw: { x: b.x - hs, y: b.y + b.h - hs, w: s, h: s },
                    se: { x: b.x + b.w - hs, y: b.y + b.h - hs, w: s, h: s },
                    n:  { x: b.x + b.w/2 - hs, y: b.y - hs, w: s, h: s },
                    s:  { x: b.x + b.w/2 - hs, y: b.y + b.h - hs, w: s, h: s },
                    w:  { x: b.x - hs, y: b.y + b.h/2 - hs, w: s, h: s },
                    e:  { x: b.x + b.w - hs, y: b.y + b.h/2 - hs, w: s, h: s },
                    rot: { x: b.x + b.w/2 - hs, y: b.y - CONFIG.rotateHandleOffset - hs, w: s, h: s }
                };
            }

            // --- Interaction Logic ---

            function getCoords(e) {
                if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
                return { x: e.clientX, y: e.clientY };
            }

            function handlePointerDown(e) {
                if (e.type === 'mousedown' && e.button !== 0) return;
                const { x, y } = getCoords(e);
                state.isPointerDown = true;
                state.pointerX = x; state.pointerY = y;

                // Eyedropper Logic
                if (colorPicker.picking) {
                    // Defer to click event
                    return; 
                }

                if (state.tool === 'text') {
                    handleTextClick(x, y);
                    return; 
                }

                if (state.textEntry.active) {
                    commitTextEntry();
                    return;
                }

                if (state.tool === 'select') {
                    // Check handles first
                    if (state.selection.items.length > 0 && state.selection.bounds) {
                        const handle = getHandleAt(x, y, state.selection.bounds);
                        if (handle) {
                            state.selection.mode = handle === 'rot' ? 'rotate' : 'resize';
                            state.selection.handleHit = handle;
                            state.selection.dragStartX = x;
                            state.selection.dragStartY = y;
                            // Store initial bounds and item states for reference during transform
                            state.selection.initialBounds = { ...state.selection.bounds };
                            return;
                        }
                        
                        // Check inside box for move
                        if (isInside(x, y, state.selection.bounds)) {
                            state.selection.mode = 'move';
                            state.selection.dragStartX = x;
                            state.selection.dragStartY = y;
                            return;
                        }
                    }

                    // Start new selection box
                    handleSelectionStart(x, y);
                } else {
                    state.activeStrokes = []; 
                    if (state.tool === 'smooth') state.penPos = { x, y };
                    startStroke(x, y);
                    render();
                }
            }

            function handlePointerMove(e) {
                const { x, y } = getCoords(e);
                state.pointerX = x; state.pointerY = y;
                
                // Hover Effects
                if (state.tool === 'select' && !state.isPointerDown) {
                    updateCursor(x, y);
                }

                if (!state.isPointerDown) return;
                if (e.cancelable) e.preventDefault();

                if (state.tool === 'select') {
                    if (state.selection.mode === 'move') {
                        handleMove(x, y);
                    } else if (state.selection.mode === 'resize') {
                        handleResize(x, y, e.shiftKey);
                    } else if (state.selection.mode === 'rotate') {
                        handleRotate(x, y, e.shiftKey);
                    } else if (state.selection.mode === 'select-box') {
                        render(); // Box drawn in render()
                    }
                } else if (state.tool !== 'text' && !colorPicker.picking) {
                    handleDrawingMove(x, y);
                }
            }

            function handlePointerUp(e) {
                // Eyedropper Click Handling
                if (colorPicker.picking) {
                    const { x, y } = getCoords(e);
                    if (colorPicker.handleCanvasClick(ctx, x, y)) {
                        state.isPointerDown = false;
                        return;
                    }
                }

                if (!state.isPointerDown) return;
                state.isPointerDown = false;
                
                if (state.tool === 'select') {
                    if (state.selection.mode === 'select-box') {
                        handleSelectionBoxEnd();
                    } else if (['move', 'resize', 'rotate'].includes(state.selection.mode)) {
                        DocManager.saveToHistory();
                    }
                    state.selection.mode = 'none';
                } else if (state.tool !== 'text') {
                    state.activeStrokes = [];
                    DocManager.saveToHistory();
                    colorPicker.addToSwatches(state.color);
                }
            }

            // --- Transform Logic ---

            function getHandleAt(x, y, b) {
                const handles = getSelectionHandles(b);
                const hitDist = 8; // generous hit area
                
                // Check Rotate first
                if (dist(x, y, handles.rot.x + 5, handles.rot.y + 5) < 10) return 'rot';
                
                for (let key in handles) {
                    if (key === 'rot') continue;
                    const h = handles[key];
                    if (x >= h.x - 2 && x <= h.x + h.w + 2 && y >= h.y - 2 && y <= h.y + h.h + 2) {
                        return key;
                    }
                }
                return null;
            }

            function updateCursor(x, y) {
                if (state.selection.items.length > 0 && state.selection.bounds) {
                    const handle = getHandleAt(x, y, state.selection.bounds);
                    if (handle) {
                        const cursors = {
                            'n': 'ns-resize', 's': 'ns-resize',
                            'e': 'ew-resize', 'w': 'ew-resize',
                            'nw': 'nwse-resize', 'se': 'nwse-resize',
                            'ne': 'nesw-resize', 'sw': 'nesw-resize',
                            'rot': 'grab'
                        };
                        canvasContainer.style.cursor = cursors[handle];
                        return;
                    }
                    if (isInside(x, y, state.selection.bounds)) {
                        canvasContainer.style.cursor = 'move';
                        return;
                    }
                }
                canvasContainer.style.cursor = 'default';
            }

            function handleMove(x, y) {
                const dx = x - state.selection.dragStartX;
                const dy = y - state.selection.dragStartY;
                
                state.selection.items.forEach(idx => {
                    const s = state.strokes[idx];
                    if (s.type === 'text') {
                        s.x += dx; s.y += dy;
                    } else if (s.type === 'image') {
                        s.x += dx; s.y += dy;
                    } else {
                        s.points.forEach(pt => { pt.x += dx; pt.y += dy; });
                    }
                });
                
                if (state.selection.bounds) {
                    state.selection.bounds.x += dx;
                    state.selection.bounds.y += dy;
                }
                
                state.selection.dragStartX = x;
                state.selection.dragStartY = y;
                render();
            }

            function handleResize(x, y, maintainAspect) {
                const b = state.selection.initialBounds; // Use initial bounds for stable scaling
                if (!b) return;

                const handle = state.selection.handleHit;
                let scaleX = 1;
                let scaleY = 1;

                // Determine Origin (Anchor Point)
                let anchorX = handle.includes('w') ? b.x + b.w : b.x;
                let anchorY = handle.includes('n') ? b.y + b.h : b.y;
                
                let dx = x - state.selection.dragStartX;
                let dy = y - state.selection.dragStartY;
                
                // Constraint deltas based on handle
                if (handle === 'n' || handle === 's') dx = 0;
                if (handle === 'e' || handle === 'w') dy = 0;
                
                const curBounds = state.selection.bounds;
                let newW = curBounds.w;
                let newH = curBounds.h;
                
                if (handle.includes('e')) newW += dx;
                if (handle.includes('w')) newW -= dx;
                if (handle.includes('s')) newH += dy;
                if (handle.includes('n')) newH -= dy;
                
                // Prevent inversion/zero
                if (newW < 5) newW = 5; 
                if (newH < 5) newH = 5;

                let sx = newW / curBounds.w;
                let sy = newH / curBounds.h;
                
                if (maintainAspect) {
                    const maxS = Math.max(sx, sy);
                    sx = maxS; sy = maxS;
                    // Recalculate W/H based on locked aspect
                    if (handle.includes('e') || handle.includes('w')) newW = curBounds.w * sx;
                    if (handle.includes('s') || handle.includes('n')) newH = curBounds.h * sy;
                }

                state.selection.items.forEach(idx => {
                    const s = state.strokes[idx];
                    
                    if (s.type === 'text') {
                        s.x = anchorX + (s.x - anchorX) * sx;
                        s.y = anchorY + (s.y - anchorY) * sy;
                        s.size *= (sx + sy) / 2; // Approx text scaling
                    } else if (s.type === 'image') {
                        s.x = anchorX + (s.x - anchorX) * sx;
                        s.y = anchorY + (s.y - anchorY) * sy;
                        s.w *= sx;
                        s.h *= sy;
                    } else {
                        s.size *= (sx + sy) / 2; // Scale stroke weight
                        s.points.forEach(pt => {
                            pt.x = anchorX + (pt.x - anchorX) * sx;
                            pt.y = anchorY + (pt.y - anchorY) * sy;
                        });
                    }
                });

                updateSelectionBounds();
                state.selection.dragStartX = x; // Reset drag delta since we applied it
                state.selection.dragStartY = y;
                render();
            }

            function handleRotate(x, y, snap) {
                const b = state.selection.bounds;
                const cx = b.x + b.w / 2;
                const cy = b.y + b.h / 2;
                
                // Angle from center to mouse
                let angle = Math.atan2(y - cy, x - cx) - Math.atan2(state.selection.dragStartY - cy, state.selection.dragStartX - cx);
                
                if (snap) {
                   // Simple snap implementation could go here, but relative rotation is smoother for UX
                }

                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                state.selection.items.forEach(idx => {
                    const s = state.strokes[idx];
                    
                    if (s.type === 'text') {
                        // Rotate position
                        const nx = cx + (s.x - cx) * cos - (s.y - cy) * sin;
                        const ny = cy + (s.x - cx) * sin + (s.y - cy) * cos;
                        s.x = nx;
                        s.y = ny;
                        s.rotation = (s.rotation || 0) + angle;
                    } else if (s.type === 'image') {
                        // Image rotation
                        const nx = cx + (s.x + s.w/2 - cx) * cos - (s.y + s.h/2 - cy) * sin;
                        const ny = cy + (s.x + s.w/2 - cx) * sin + (s.y + s.h/2 - cy) * cos;
                        // Center needs to move to new pos, then calc top-left
                        s.x = nx - s.w/2;
                        s.y = ny - s.h/2;
                        s.rotation = (s.rotation || 0) + angle;
                    } else {
                        // Rotate points
                        s.points.forEach(pt => {
                            const nx = cx + (pt.x - cx) * cos - (pt.y - cy) * sin;
                            const ny = cy + (pt.x - cx) * sin + (pt.y - cy) * cos;
                            pt.x = nx;
                            pt.y = ny;
                        });
                    }
                });

                updateSelectionBounds(); // Box rotates with content (resizes to fit)
                state.selection.dragStartX = x;
                state.selection.dragStartY = y;
                render();
            }

            // --- Drawing Logic (Adapted) ---
            function handleDrawingMove(x, y) {
                const w = canvas.width / window.devicePixelRatio; 
                const h = canvas.height / window.devicePixelRatio;
                let targetX = x;
                let targetY = y;

                if (state.tool === 'smooth') {
                    const smoothVal = parseInt(ui.smoothing.value);
                    const friction = 1 - (smoothVal / 35);
                    state.penPos.x += (x - state.penPos.x) * friction;
                    state.penPos.y += (y - state.penPos.y) * friction;
                    targetX = state.penPos.x;
                    targetY = state.penPos.y;
                }

                state.activeStrokes.forEach(item => {
                    let tx = targetX, ty = targetY;
                    if (item.transform === 'vert') tx = w - targetX;
                    else if (item.transform === 'horz') ty = h - targetY;
                    else if (item.transform === 'quad') { tx = w - targetX; ty = h - targetY; }

                    const lastPt = item.stroke.points[item.stroke.points.length - 1];
                    const dist = Math.hypot(tx - lastPt.x, ty - lastPt.y);
                    if (dist > 2) {
                        item.stroke.points.push({ x: tx, y: ty });
                    }
                });
                render();
            }

            // --- Text Tool Logic ---

            function handleTextClick(x, y) {
                // Check if clicking existing text
                const clickedTextIndex = findTextAt(x, y);
                
                if (clickedTextIndex !== -1) {
                    // Edit existing
                    editText(clickedTextIndex);
                } else {
                    // Start new
                    if (state.textEntry.active) commitTextEntry(); // Commit previous
                    startTextEntry(x, y);
                }
            }

            function startTextEntry(x, y, existingIndex = -1) {
                state.textEntry.active = true;
                state.textEntry.x = x;
                state.textEntry.y = y;
                state.textEntry.targetIndex = existingIndex;

                textHelper.style.display = 'block';
                textHelper.style.left = x + 'px';
                textHelper.style.top = y + 'px';
                textHelper.style.fontSize = ui.size.value + 'px';
                textHelper.style.color = state.color; // Use new color state
                
                if (existingIndex !== -1) {
                    textHelper.value = state.strokes[existingIndex].text;
                } else {
                    textHelper.value = '';
                }
                
                // Adjust textarea size
                textHelper.style.width = '200px';
                textHelper.style.height = '100px';
                
                setTimeout(() => textHelper.focus(), 10);
            }

            function commitTextEntry() {
                if (!state.textEntry.active) return;

                const text = textHelper.value.trim();
                if (text) {
                    const textObj = {
                        type: 'text',
                        x: state.textEntry.x,
                        y: state.textEntry.y,
                        text: text,
                        size: parseInt(ui.size.value),
                        color: state.color,
                        weight: 'normal',
                        font: 'sans-serif',
                        rotation: 0
                    };

                    if (state.textEntry.targetIndex !== -1) {
                        // Preserve existing props like rotation
                        const existing = state.strokes[state.textEntry.targetIndex];
                        textObj.x = existing.x;
                        textObj.y = existing.y;
                        textObj.rotation = existing.rotation;
                        state.strokes[state.textEntry.targetIndex] = textObj;
                    } else {
                        state.strokes.push(textObj);
                    }
                    DocManager.saveToHistory();
                } else if (state.textEntry.targetIndex !== -1) {
                    state.strokes.splice(state.textEntry.targetIndex, 1);
                    DocManager.saveToHistory();
                }

                state.textEntry.active = false;
                state.textEntry.targetIndex = -1;
                textHelper.style.display = 'none';
                textHelper.value = '';
                render();
            }

            function editText(index) {
                const obj = state.strokes[index];
                ui.size.value = obj.size;
                
                // Update color picker to match edit text
                state.color = obj.color;
                colorPicker.setColor(state.color);
                
                startTextEntry(obj.x, obj.y, index);
                render(); 
            }

            function findTextAt(x, y) {
                for (let i = state.strokes.length - 1; i >= 0; i--) {
                    const s = state.strokes[i];
                    if (s.type === 'text') {
                        const bounds = measureTextBoundsSimple(s);
                        // Simple AABB Hit test (doesn't account for rotation perfectly but good enough for selection)
                        if (x >= bounds.x && x <= bounds.x + bounds.w &&
                            y >= bounds.y && y <= bounds.y + bounds.h) {
                            return i;
                        }
                    }
                }
                return -1;
            }

            function measureTextBoundsSimple(obj) {
                ctx.save();
                ctx.font = `${obj.weight || 'normal'} ${obj.size}px ${obj.font || 'sans-serif'}`;
                const lines = obj.text.split('\n');
                let maxWidth = 0;
                lines.forEach(line => {
                    const w = ctx.measureText(line).width;
                    if (w > maxWidth) maxWidth = w;
                });
                const lineHeight = obj.size * 1.2;
                const height = lines.length * lineHeight;
                ctx.restore();
                return { x: obj.x, y: obj.y, w: maxWidth, h: height };
            }

            // --- Standard Drawing Logic (Helpers) ---

            function startStroke(x, y) {
                const baseProps = {
                    color: state.color, // Use new color state
                    size: parseInt(ui.size.value),
                    type: state.tool === 'eraser' ? 'eraser' : state.tool, 
                    angle: parseInt(ui.angle.value)
                };
                
                if (state.tool === 'mirror' || state.tool === 'smooth') baseProps.type = 'brush';

                const s1 = { ...baseProps, points: [{ x, y }] };
                state.strokes.push(s1);
                state.activeStrokes.push({ stroke: s1, transform: 'none' });

                if (state.tool === 'mirror') {
                    const w = canvas.width / window.devicePixelRatio; 
                    const h = canvas.height / window.devicePixelRatio;
                    if (state.mirrorMode === 'vertical' || state.mirrorMode === 'quad') {
                        const s2 = { ...baseProps, points: [{ x: w - x, y }] };
                        state.strokes.push(s2); state.activeStrokes.push({ stroke: s2, transform: 'vert' });
                    }
                    if (state.mirrorMode === 'horizontal' || state.mirrorMode === 'quad') {
                        const s3 = { ...baseProps, points: [{ x, y: h - y }] };
                        state.strokes.push(s3); state.activeStrokes.push({ stroke: s3, transform: 'horz' });
                    }
                    if (state.mirrorMode === 'quad') {
                        const s4 = { ...baseProps, points: [{ x: w - x, y: h - y }] };
                        state.strokes.push(s4); state.activeStrokes.push({ stroke: s4, transform: 'quad' });
                    }
                }
            }

            // --- Selection Helpers ---
            function handleSelectionStart(x, y) {
                // Check intersection with items
                // If not hitting existing selection, clear it
                if (!state.selection.items.length || !isInside(x,y, state.selection.bounds)) {
                     // Check single click selection
                    const textIndex = findTextAt(x, y);
                    if (textIndex !== -1) {
                        state.selection.items = [textIndex];
                        updateSelectionBounds();
                        updateDeleteButton();
                        // Prepare Drag
                        state.selection.mode = 'move';
                        state.selection.dragStartX = x;
                        state.selection.dragStartY = y;
                        render();
                        return;
                    }

                    // Check image intersection
                    // Find topmost image under cursor
                    let imgIndex = -1;
                    for (let i = state.strokes.length - 1; i >= 0; i--) {
                        if (state.strokes[i].type === 'image') {
                            const img = state.strokes[i];
                            // Simple box check (ignoring rotation for hit test for simplicity, can upgrade to poly check)
                            // To be accurate with rotation we'd map mouse point to local coords
                            if (x >= img.x && x <= img.x + img.w && y >= img.y && y <= img.y + img.h) {
                                imgIndex = i;
                                break;
                            }
                        }
                    }
                    if (imgIndex !== -1) {
                        state.selection.items = [imgIndex];
                        updateSelectionBounds();
                        updateDeleteButton();
                        state.selection.mode = 'move';
                        state.selection.dragStartX = x;
                        state.selection.dragStartY = y;
                        render();
                        return;
                    }
                    
                    // Start Box Select
                    state.selection.items = [];
                    state.selection.bounds = null;
                    state.selection.mode = 'select-box';
                    state.selection.dragStartX = x;
                    state.selection.dragStartY = y;
                    updateDeleteButton();
                }
                render();
            }

            function handleSelectionBoxEnd() {
                const x1 = Math.min(state.selection.dragStartX, state.pointerX);
                const y1 = Math.min(state.selection.dragStartY, state.pointerY);
                const w = Math.abs(state.pointerX - state.selection.dragStartX);
                const h = Math.abs(state.pointerY - state.selection.dragStartY);
                
                if (w > 0 && h > 0) {
                    selectStrokesInBox(x1, y1, w, h);
                } else {
                    // Clicked on empty space -> Clear
                    state.selection.items = [];
                    state.selection.bounds = null;
                    updateDeleteButton();
                    render();
                }
            }

            function isInside(x, y, b) { 
                if(!b) return false;
                return x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h; 
            }
            
            function dist(x1, y1, x2, y2) { return Math.hypot(x2-x1, y2-y1); }

            function selectStrokesInBox(x, y, w, h) {
                state.selection.items = [];
                if (w < 5 && h < 5) { w = 10; h = 10; x -= 5; y -= 5; }
                
                state.strokes.forEach((s, i) => {
                   let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                   
                   if (s.type === 'text') {
                       const b = measureTextBoundsSimple(s);
                       minX = b.x; maxX = b.x + b.w; minY = b.y; maxY = b.y + b.h;
                   } else if (s.type === 'image') {
                       minX = s.x; maxX = s.x + s.w; minY = s.y; maxY = s.y + s.h;
                   } else {
                       s.points.forEach(p=>{if(p.x<minX)minX=p.x;if(p.x>maxX)maxX=p.x;if(p.y<minY)minY=p.y;if(p.y>maxY)maxY=p.y;});
                   }
                   
                   if (maxX > x && minX < x+w && maxY > y && minY < y+h) state.selection.items.push(i);
                });
                updateSelectionBounds(); updateDeleteButton(); render();
            }

            function updateSelectionBounds() {
                if (state.selection.items.length===0) { state.selection.bounds=null; return; }
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                state.selection.items.forEach(idx => {
                    const s = state.strokes[idx];
                    if (s.type === 'text') {
                         const b = measureTextBoundsSimple(s);
                         if(b.x<minX)minX=b.x; if(b.x+b.w>maxX)maxX=b.x+b.w; if(b.y<minY)minY=b.y; if(b.y+b.h>maxY)maxY=b.y+b.h;
                    } else if (s.type === 'image') {
                        // For box calc, just use axis aligned. Rotation makes this tricky but AABB is simpler for now.
                        // Ideally, calculate rotated corners and find min/max
                        if(s.x<minX)minX=s.x; if(s.x+s.w>maxX)maxX=s.x+s.w; if(s.y<minY)minY=s.y; if(s.y+s.h>maxY)maxY=s.y+s.h;
                    } else {
                        s.points.forEach(p => { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
                    }
                });
                state.selection.bounds = {x:minX-10, y:minY-10, w:maxX-minX+20, h:maxY-minY+20};
            }

            function deleteSelection() {
                if (state.selection.items.length === 0) return;
                state.selection.items.sort((a, b) => b - a);
                state.selection.items.forEach(index => state.strokes.splice(index, 1));
                state.selection.items = []; state.selection.bounds = null;
                updateDeleteButton(); DocManager.saveToHistory(); render();
            }
            function updateDeleteButton() { ui.delete.classList.toggle('visible', state.selection.items.length > 0); }
            
            function undo() { if (state.historyStep > 0) { state.historyStep--; state.strokes = JSON.parse(state.history[state.historyStep]); state.selection.items = []; state.selection.bounds = null; render(); updateHistoryUI(); DocManager.saveCurrent(); } }
            function redo() { if (state.historyStep < state.history.length - 1) { state.historyStep++; state.strokes = JSON.parse(state.history[state.historyStep]); state.selection.items = []; state.selection.bounds = null; render(); updateHistoryUI(); DocManager.saveCurrent(); } }
            function updateHistoryUI() { ui.undo.style.opacity = state.historyStep > 0 ? '1' : '0.3'; ui.redo.style.opacity = state.historyStep < state.history.length - 1 ? '1' : '0.3'; }
            function showStatus() { ui.status.classList.add('visible'); setTimeout(() => ui.status.classList.remove('visible'), 2000); }

            // --- Tool Switching ---
            function setTool(toolName) {
                if (state.tool === 'text' && state.textEntry.active) commitTextEntry();

                state.tool = toolName;
                if (toolName !== 'select') { state.selection.items = []; state.selection.bounds = null; updateDeleteButton(); render(); }
                updateToolUI();
            }

            function updateToolUI() {
                ['brush','text','calligraphy','smooth','eraser','select','mirror'].forEach(t => {
                    ui[t].classList.toggle('active', state.tool === t);
                });
                ui.mirrorOptions.classList.toggle('visible', state.tool === 'mirror');
                ui.angleControl.classList.toggle('hidden', state.tool !== 'calligraphy');
                ui.smoothingControl.classList.toggle('hidden', state.tool !== 'smooth');
                
                canvasContainer.style.cursor = state.tool === 'select' ? 'default' : state.tool === 'text' ? 'text' : state.tool === 'eraser' ? 'cell' : 'crosshair';
            }

            // --- Events ---
            canvas.addEventListener('mousedown', handlePointerDown);
            window.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
            window.addEventListener('touchmove', handlePointerMove, { passive: false });
            window.addEventListener('touchend', handlePointerUp);
            window.addEventListener('resize', resizeCanvas);

            ui.brush.addEventListener('click', () => setTool('brush'));
            ui.text.addEventListener('click', () => setTool('text'));
            ui.calligraphy.addEventListener('click', () => setTool('calligraphy'));
            ui.smooth.addEventListener('click', () => setTool('smooth'));
            ui.eraser.addEventListener('click', () => setTool('eraser'));
            ui.select.addEventListener('click', () => setTool('select'));
            ui.mirror.addEventListener('click', () => setTool('mirror'));
            ui.mirrorAxis.addEventListener('change', (e) => { state.mirrorMode = e.target.value; render(); });
            
            ui.size.addEventListener('input', () => { 
                ui.sizeLabel.textContent = `${ui.size.value}px`; 
                if (state.textEntry.active) textHelper.style.fontSize = ui.size.value + 'px';
            });
            ui.angle.addEventListener('input', () => { ui.angleLabel.textContent = `${ui.angle.value}Â°`; });
            ui.smoothing.addEventListener('input', () => { 
                const val = ui.smoothing.value;
                ui.smoothingLabel.textContent = val < 10 ? 'Low' : val < 20 ? 'Med' : 'High';
            });
            
            ui.undo.addEventListener('click', undo);
            ui.redo.addEventListener('click', redo);
            ui.delete.addEventListener('click', deleteSelection);
            ui.clear.addEventListener('click', () => { 
                if (confirm('Clear canvas?')) { 
                    // Visual flash/fade effect for clear
                    canvasContainer.classList.add('fade-out');
                    setTimeout(() => {
                        state.strokes = []; 
                        state.selection.items = []; 
                        state.selection.bounds = null; 
                        DocManager.saveToHistory(); 
                        render(); 
                        canvasContainer.classList.remove('fade-out');
                    }, 300);
                } 
            });
            
            ui.download.addEventListener('click', () => {
                const link = document.createElement('a'); link.download = `${ui.docTitle.value.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.png`;
                
                // COMPOSITE EXPORT STRATEGY:
                // 1. Create temp canvas
                // 2. Fill with "paper color" (excluding grid)
                // 3. Draw original strokes on top
                // 4. Export
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tCtx = tempCanvas.getContext('2d');
                
                // Get current paper color
                const style = getComputedStyle(document.documentElement);
                const paperColor = style.getPropertyValue('--canvas-paper').trim();
                
                // Fill background
                tCtx.fillStyle = paperColor;
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                // Draw original canvas (strokes + transparency)
                tCtx.drawImage(canvas, 0, 0);
                
                link.href = tempCanvas.toDataURL(); 
                link.click();
            });

            // SVG Export
            ui.exportSvg.addEventListener('click', () => {
                const svg = SVGExporter.export(state.strokes, ui.docTitle.value);
                SVGExporter.download(svg, ui.docTitle.value.replace(/[^a-z0-9]/gi, '-').toLowerCase());
            });

            // SVG Import UI triggers
            ui.btnImport.addEventListener('click', () => {
                fileInput.click();
            });
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    SVGImporter.handleFile(e.target.files[0]);
                    fileInput.value = ''; // Reset
                    closeGallery();
                }
            });

            // Image Import UI triggers
            ui.btnImportImg.addEventListener('click', () => {
                imgInput.click();
            });
            imgInput.addEventListener('change', (e) => {
                 if (e.target.files.length > 0) {
                    ImageImporter.handleFile(e.target.files[0]);
                    imgInput.value = '';
                    closeGallery();
                 }
            });
            
            ui.galleryBtn.addEventListener('click', openGallery);
            ui.modalClose.addEventListener('click', closeGallery);
            ui.modal.addEventListener('click', (e) => { if(e.target === ui.modal) closeGallery(); });
            ui.btnNew.addEventListener('click', () => { const doc = DocManager.create(); DocManager.load(doc.id); closeGallery(); });
            ui.docTitle.addEventListener('change', () => { DocManager.saveCurrent(); });
            ui.btnTheme.addEventListener('click', ThemeManager.toggle);

            // Toggle Grid Logic
            ui.btnGrid.addEventListener('click', () => {
                canvasContainer.classList.toggle('show-grid');
            });

            // Blur text entry on Enter (Shift+Enter for new line)
            textHelper.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    commitTextEntry();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (state.textEntry.active) return; // Don't trigger shortcuts while typing

                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                if (e.key === 'Delete' || e.key === 'Backspace') deleteSelection();
                if (e.target.tagName === 'INPUT') return;
                if (e.key.toLowerCase() === 'b') setTool('brush');
                if (e.key.toLowerCase() === 't') setTool('text');
                if (e.key.toLowerCase() === 'c') setTool('calligraphy');
                if (e.key.toLowerCase() === 's') setTool('smooth');
                if (e.key.toLowerCase() === 'e') setTool('eraser');
                if (e.key.toLowerCase() === 'v') setTool('select');
                if (e.key.toLowerCase() === 'm') setTool('mirror');
            });

            init();
        });
    </script>
</body>
</html>